# 授权信息不同步问题修复说明

## 问题描述
用户反馈：
1. 若第一次直接点击"一键登录"，姿势厅的收藏、使用、查看图片等功能都正常
2. 若先点击"先逛逛"，再去个人中心登录授权后，回到姿势厅就无法收藏图片
3. 点击图片下方的"使用"按钮会一直显示 `temp_image_1763108854296.png`

## 问题根源

### 1. 授权流程不一致
- **弹窗一键登录** (`index.js` 的 `onAuthAgree`)：
  - ✅ 调用 `authorizeLogin()` 
  - ✅ 保存 token 到多个位置
  - ✅ 清除游客模式标记 `auth_bypassed`
  - ✅ 调用 `setToken()` 同步到 request.js
  - ❌ **但没有触发数据同步** `syncAll()`（这个在 auth.js 中自动触发）

- **个人中心登录** (`profile/index.js` 的 `onTapProfileLogin`)：
  - ✅ 调用 `authorizeLogin()`
  - ❌ **没有保存 token 到所有必要位置**
  - ❌ **没有清除游客模式标记**
  - ❌ **没有调用 setToken() 同步到 request.js**
  - ❌ **没有触发数据同步**

### 2. 登录状态检查机制
- `authUtil.isLoggedIn()` 检查：
  - 检查 `auth_bypassed` 是否为 true（游客模式）
  - 检查是否有 token
  - 检查是否有用户信息

- 如果个人中心登录后没有清除 `auth_bypassed`，会被误判为游客模式

### 3. 数据同步问题
- `auth.js` 中的 `authorizeLogin()` 会在登录成功后自动调用 `syncAll()`
- 但这个同步是异步的，需要确保 token 已经保存

## 修复方案

### 已修复的文件

#### 1. `miniprogram/pages/profile/index.js`
修复了 `onTapProfileLogin` 方法，确保：
- ✅ 接收并保存后端返回的 token
- ✅ 保存 token 到多个位置（token, auth_token）
- ✅ 调用 `setToken()` 同步到 request.js
- ✅ 清除游客模式标记 `auth_bypassed`
- ✅ 数据同步由 auth.js 自动处理

### 修复后的登录流程

```
用户点击个人中心登录
    ↓
调用 authorizeLogin(externalUser)
    ↓
后端返回 { mergedUser, token }
    ↓
保存 token 到：
  - wx.setStorageSync('token', token)
  - wx.setStorageSync('auth_token', token)
  - require('../../utils/request.js').setToken(token)
    ↓
清除游客模式标记：
  - wx.removeStorageSync('auth_bypassed')
    ↓
更新本地用户信息：
  - setData({ profile: { ...mergedUser, hasAuth: true } })
  - wx.setStorageSync('profile_basic', { ...mergedUser, hasAuth: true })
    ↓
auth.js 自动触发数据同步：
  - syncAll() 同步收藏、历史等数据
```

## 测试验证

### 测试场景 1：直接一键登录
1. 打开小程序
2. 点击弹窗的"一键登录"
3. 授权后进入姿势厅
4. ✅ 应该能正常收藏图片
5. ✅ 点击"使用"按钮应该正常跳转

### 测试场景 2：先逛逛后登录
1. 打开小程序
2. 点击"先逛逛"
3. 进入个人中心
4. 点击"点击登录"并授权
5. 返回姿势厅
6. ✅ 应该能正常收藏图片
7. ✅ 点击"使用"按钮应该正常跳转
8. ✅ 不应该出现 temp_image 问题

## 关键代码变更

### 变更前
```javascript
onTapProfileLogin() {
  // ...
  authorizeLogin(externalUser)
    .then(({ mergedUser }) => {
      // 只更新了本地状态，没有处理 token
      this.setData({ profile: { ...mergedUser, hasAuth: true } });
      // ...
    })
}
```

### 变更后
```javascript
onTapProfileLogin() {
  // ...
  authorizeLogin(externalUser)
    .then(({ mergedUser, token }) => {
      // 1. 保存 token
      if (typeof token === 'string' && token) {
        wx.setStorageSync('token', token);
        wx.setStorageSync('auth_token', token);
        require('../../utils/request.js').setToken(token);
      }
      
      // 2. 清除游客模式
      wx.removeStorageSync('auth_bypassed');
      
      // 3. 更新用户信息
      this.setData({ profile: { ...mergedUser, hasAuth: true } });
      wx.setStorageSync('profile_basic', { ...mergedUser, hasAuth: true });
      // ...
    })
}
```

## 注意事项

1. **Token 同步**：确保 token 保存到所有必要的位置
2. **游客模式标记**：登录成功后必须清除 `auth_bypassed`
3. **数据同步**：auth.js 会自动触发，但需要确保 token 已保存
4. **登录状态检查**：使用统一的 `authUtil.isLoggedIn()` 方法

## 相关文件

- `miniprogram/pages/profile/index.js` - 个人中心登录逻辑
- `miniprogram/pages/index/index.js` - 首页一键登录逻辑
- `miniprogram/utils/auth.js` - 统一授权工具
- `miniprogram/utils/request.js` - 请求封装
- `miniprogram/utils/storage.js` - 存储工具
- `miniprogram/utils/sync.js` - 数据同步工具